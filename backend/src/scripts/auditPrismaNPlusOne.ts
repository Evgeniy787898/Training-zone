import { promises as fs } from 'node:fs';
import path from 'node:path';
import ts from 'typescript';
import { fileURLToPath } from 'node:url';

interface Finding {
    filePath: string;
    line: number;
    column: number;
    snippet: string;
    loopType?: string;
    iterator?: string;
    model?: string;
    method?: string;
}

const loopKinds = new Set<ts.SyntaxKind>([
    ts.SyntaxKind.ForStatement,
    ts.SyntaxKind.ForInStatement,
    ts.SyntaxKind.ForOfStatement,
    ts.SyntaxKind.WhileStatement,
    ts.SyntaxKind.DoStatement,
]);

const iteratorMethods = new Set([
    'map',
    'forEach',
    'filter',
    'reduce',
    'flatMap',
    'some',
    'every',
]);

const scriptDir = path.dirname(fileURLToPath(import.meta.url));
const backendRoot = path.resolve(scriptDir, '../..');
const repoRoot = path.resolve(backendRoot, '..');
const srcDir = path.join(backendRoot, 'src');
const docsDir = path.join(repoRoot, 'docs');
const reportPath = path.join(docsDir, 'prisma-n-plus-one-audit.md');

async function main() {
    const files = await collectFiles(srcDir);
    const findings: Finding[] = [];

    for (const filePath of files) {
        const content = await fs.readFile(filePath, 'utf8');
        const sourceFile = ts.createSourceFile(filePath, content, ts.ScriptTarget.Latest, true, ts.ScriptKind.TS);
        const lines = content.split(/\r?\n/);

        traverse(sourceFile, []);

        function traverse(node: ts.Node, ancestors: ts.Node[]) {
            if (ts.isAwaitExpression(node)) {
                const callInfo = extractPrismaCall(node.expression);
                if (callInfo) {
                    const loopAncestor = findLoopAncestor(ancestors);
                    const iteratorAncestor = findIteratorAncestor(ancestors);
                    if (loopAncestor || iteratorAncestor) {
                        const { line, character } = sourceFile.getLineAndCharacterOfPosition(node.getStart());
                        const snippet = lines[line]?.trim() ?? '';
                        findings.push({
                            filePath,
                            line: line + 1,
                            column: character + 1,
                            snippet,
                            loopType: loopAncestor ? ts.SyntaxKind[loopAncestor.kind] : undefined,
                            iterator: iteratorAncestor,
                            model: callInfo.model,
                            method: callInfo.method,
                        });
                    }
                }
            }

            node.forEachChild((child) => traverse(child, [...ancestors, node]));
        }
    }

    await fs.mkdir(docsDir, { recursive: true });
    const outputLines: string[] = [];
    outputLines.push('# Prisma N+1 Audit Report');
    outputLines.push('');
    outputLines.push(`_Generated at ${new Date().toISOString()}_`);
    outputLines.push('');

    if (findings.length === 0) {
        outputLines.push('✅ **No potential N+1 patterns were detected by the static analyzer.**');
        outputLines.push('');
    } else {
        outputLines.push(`⚠️ **Potential N+1 patterns detected:** ${findings.length}`);
        outputLines.push('');
        const grouped = groupFindings(findings);
        for (const [file, fileFindings] of grouped) {
            outputLines.push(`## ${file}`);
            outputLines.push('');
            for (const finding of fileFindings) {
                const location = `Line ${finding.line}, Col ${finding.column}`;
                const loop = finding.loopType ? `Loop: ${finding.loopType}` : `Iterator: ${finding.iterator}`;
                const target = finding.model ? `${finding.model}.${finding.method}` : finding.method ?? 'unknown call';
                outputLines.push(`- ${location} — ${loop} — \`${target}\``);
                if (finding.snippet) {
                    outputLines.push(`  - Context: \`${finding.snippet}\``);
                }
            }
            outputLines.push('');
        }
    }

    outputLines.push('---');
    outputLines.push('');
    outputLines.push('> This report is generated by `npm run audit:nplusone` and relies on static heuristics. Review each finding manually to confirm whether it is a real N+1 issue or a false positive.');
    outputLines.push('');

    await fs.writeFile(reportPath, outputLines.join('\n'));
    console.log(`N+1 audit complete. ${findings.length} potential issue(s) written to ${path.relative(repoRoot, reportPath)}.`);
}

async function collectFiles(dir: string): Promise<string[]> {
    const entries = await fs.readdir(dir, { withFileTypes: true });
    const files: string[] = [];
    for (const entry of entries) {
        if (entry.name.startsWith('.')) continue;
        if (['node_modules', 'dist', 'prisma', '__tests__'].includes(entry.name)) continue;
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory()) {
            files.push(...await collectFiles(fullPath));
        } else if (entry.isFile() && entry.name.endsWith('.ts') && !entry.name.endsWith('.d.ts')) {
            files.push(fullPath);
        }
    }
    return files;
}

function extractPrismaCall(expression: ts.Expression): { model?: string; method?: string } | null {
    if (!ts.isCallExpression(expression)) return null;
    const chain = getPropertyChain(expression.expression);
    const prismaIndex = chain.indexOf('prisma');
    if (prismaIndex === -1) return null;
    const model = chain[prismaIndex + 1];
    const method = chain[chain.length - 1];
    return { model, method };
}

function getPropertyChain(expression: ts.Expression): string[] {
    const names: string[] = [];
    let current: ts.Expression | undefined = expression;
    while (current && ts.isPropertyAccessExpression(current)) {
        names.unshift(current.name.text);
        current = current.expression;
    }
    if (current && ts.isIdentifier(current)) {
        names.unshift(current.text);
    } else if (current && current.kind === ts.SyntaxKind.ThisKeyword) {
        names.unshift('this');
    }
    return names;
}

function findLoopAncestor(ancestors: ts.Node[]): ts.Node | undefined {
    for (let i = ancestors.length - 1; i >= 0; i -= 1) {
        if (loopKinds.has(ancestors[i].kind)) {
            return ancestors[i];
        }
    }
    return undefined;
}

function findIteratorAncestor(ancestors: ts.Node[]): string | undefined {
    for (let i = ancestors.length - 1; i >= 0; i -= 1) {
        const node = ancestors[i];
        if (ts.isCallExpression(node) && ts.isPropertyAccessExpression(node.expression)) {
            const candidate = node.expression.name.text;
            if (iteratorMethods.has(candidate)) {
                return candidate;
            }
        }
    }
    return undefined;
}

function groupFindings(findings: Finding[]): Map<string, Finding[]> {
    const grouped = new Map<string, Finding[]>();
    for (const finding of findings) {
        const relative = path.relative(repoRoot, finding.filePath);
        if (!grouped.has(relative)) {
            grouped.set(relative, []);
        }
        grouped.get(relative)!.push(finding);
    }
    for (const [, fileFindings] of grouped) {
        fileFindings.sort((a, b) => a.line - b.line);
    }
    return grouped;
}

main().catch((error) => {
    console.error('Failed to run Prisma N+1 audit');
    console.error(error);
    process.exit(1);
});
